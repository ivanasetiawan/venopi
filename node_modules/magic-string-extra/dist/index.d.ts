import * as MagicString from 'magic-string';
import MagicString__default, { ExclusionRange, SourceMap, IndentOptions, OverwriteOptions } from 'magic-string';
export { ExclusionRange, IndentOptions, OverwriteOptions, SourceMap } from 'magic-string';

interface SourceMapOptions {
    /**
     * Whether the mapping should be high-resolution.
     * Hi-res mappings map every single character, meaning (for example) your devtools will always
     * be able to pinpoint the exact location of function calls and so on.
     * With lo-res mappings, devtools may only be able to identify the correct
     * line - but they're quicker to generate and less bulky.
     * If sourcemap locations have been specified with s.addSourceMapLocation(), they will be used here.
     */
    hires: boolean;
    /**
     * The filename where you plan to write the sourcemap.
     */
    file: string;
    /**
     * The filename of the file containing the original source.
     */
    source: string;
    /**
     * Whether to include the original content in the map's sourcesContent array.
     */
    includeContent: boolean;
}
interface MagicStringOptions {
    filename: string;
    indentExclusionRanges: ExclusionRange | Array<ExclusionRange>;
    /**
     * The default sourcemap options.
     */
    sourcemapOptions: Partial<SourceMapOptions>;
}

declare class MagicStringExtra {
    private s;
    private defaultSourcemapOptions;
    constructor(s: MagicString__default);
    constructor(code: string, options?: Partial<MagicStringOptions>);
    /**
     * Do a String.replace with magic!
     *
     * Caveat:
     * - It will always match against the **original string**
     * - It mutates the magic string state (use `.clone()` to be immutable)
     */
    replace(regex: RegExp | string, replacement: string | ((substring: string, ...args: any[]) => string)): this;
    /**
     * A shorthand to generate the result in Rollup's `TransformResult` format.
     * When the string has not changed, `null` will be returned skip the Rollup transformation.
     */
    toRollupResult(sourcemap?: boolean, options?: Partial<SourceMapOptions>): {
        code: string;
        map?: SourceMap | undefined;
    } | null;
    /**
     * Check if this magic string has been changed. Useful to bypass unnecessary transformations.
     */
    hasChanged(): boolean;
    /**
     * Returns the generated string.
     */
    toString(): string;
    /**
     * Get the original source string.
     */
    get original(): string;
    /**
     * Adds the specified character index (with respect to the original string) to sourcemap mappings, if `hires` is false.
     */
    addSourcemapLocation(char: number): void;
    /**
     * Appends the specified content to the end of the string.
     */
    append(content: string): this;
    /**
     * Appends the specified content at the index in the original string.
     * If a range *ending* with index is subsequently moved, the insert will be moved with it.
     * See also `s.prependLeft(...)`.
     */
    appendLeft(index: number, content: string): this;
    /**
     * Appends the specified content at the index in the original string.
     * If a range *starting* with index is subsequently moved, the insert will be moved with it.
     * See also `s.prependRight(...)`.
     */
    appendRight(index: number, content: string): this;
    /**
     * Does what you'd expect.
     */
    clone(): MagicStringExtra;
    /**
     * Generates a version 3 sourcemap.
     */
    generateMap(options?: Partial<SourceMapOptions>): SourceMap;
    /**
     * Generates a sourcemap object with raw mappings in array form, rather than encoded as a string.
     * Useful if you need to manipulate the sourcemap further, but most of the time you will use `generateMap` instead.
     */
    generateDecodedMap(options?: Partial<SourceMapOptions>): MagicString.DecodedSourceMap;
    getIndentString(): string;
    /**
     * Prefixes each line of the string with prefix.
     * If prefix is not supplied, the indentation will be guessed from the original content, falling back to a single tab character.
     */
    indent(options?: IndentOptions): MagicStringExtra;
    /**
     * Prefixes each line of the string with prefix.
     * If prefix is not supplied, the indentation will be guessed from the original content, falling back to a single tab character.
     *
     * The options argument can have an exclude property, which is an array of [start, end] character ranges.
     * These ranges will be excluded from the indentation - useful for (e.g.) multiline strings.
     */
    indent(indentStr?: string, options?: IndentOptions): MagicStringExtra;
    get indentExclusionRanges(): ExclusionRange | Array<ExclusionRange>;
    /**
     * Moves the characters from `start and `end` to `index`.
     */
    move(start: number, end: number, index: number): this;
    /**
     * Replaces the characters from `start` to `end` with `content`. The same restrictions as `s.remove()` apply.
     *
     * The fourth argument is optional. It can have a storeName property — if true, the original name will be stored
     * for later inclusion in a sourcemap's names array — and a contentOnly property which determines whether only
     * the content is overwritten, or anything that was appended/prepended to the range as well.
     */
    overwrite(start: number, end: number, content: string, options?: boolean | OverwriteOptions): this;
    /**
     * Prepends the string with the specified content.
     */
    prepend(content: string): this;
    /**
     * Same as `s.appendLeft(...)`, except that the inserted content will go *before* any previous appends or prepends at index
     */
    prependLeft(index: number, content: string): this;
    /**
     * Same as `s.appendRight(...)`, except that the inserted content will go *before* any previous appends or prepends at `index`
     */
    prependRight(index: number, content: string): this;
    /**
     * Removes the characters from `start` to `end` (of the original string, **not** the generated string).
     * Removing the same content twice, or making removals that partially overlap, will cause an error.
     */
    remove(start: number, end: number): MagicString__default;
    /**
     * Returns the content of the generated string that corresponds to the slice between `start` and `end` of the original string.
     * Throws error if the indices are for characters that were already removed.
     */
    slice(start: number, end: number): string;
    /**
     * Returns a clone of `s`, with all content before the `start` and `end` characters of the original string removed.
     */
    snip(start: number, end: number): this;
    /**
     * Trims content matching `charType` (defaults to `\s`, i.e. whitespace) from the start and end.
     */
    trim(charType?: string): this;
    /**
     * Trims content matching `charType` (defaults to `\s`, i.e. whitespace) from the start.
     */
    trimStart(charType?: string): this;
    /**
     * Trims content matching `charType` (defaults to `\s`, i.e. whitespace) from the end.
     */
    trimEnd(charType?: string): this;
    /**
     * Removes empty lines from the start and end.
     */
    trimLines(): this;
    lastChar(): string;
    lastLine(): string;
    /**
     * Returns true if the resulting source is empty (disregarding white space).
     */
    isEmpty(): boolean;
    length(): number;
}

export { MagicStringExtra, MagicStringOptions, SourceMapOptions, MagicStringExtra as default };
