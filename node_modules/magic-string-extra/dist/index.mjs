import MagicString from 'magic-string';

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
class MagicStringExtra {
  constructor(code, options) {
    if (typeof code === "string") {
      this.s = new MagicString(code, options);
      this.defaultSourcemapOptions = options == null ? void 0 : options.sourcemapOptions;
    } else {
      this.s = code;
    }
  }
  replace(regex, replacement) {
    function getReplacement(match) {
      if (typeof replacement === "string") {
        return replacement.replace(/\$(\$|\&|\d+)/g, (_, i) => {
          if (i === "$")
            return "$";
          if (i === "&")
            return match[0];
          const num = +i;
          if (num < match.length)
            return match[+i];
          return `$${i}`;
        });
      } else {
        return replacement(...match);
      }
    }
    if (typeof regex !== "string" && regex.global) {
      const matches = Array.from(this.original.matchAll(regex));
      matches.forEach((match) => {
        if (match.index != null)
          this.s.overwrite(match.index, match.index + match[0].length, getReplacement(match));
      });
    } else {
      const match = this.original.match(regex);
      if ((match == null ? void 0 : match.index) != null)
        this.s.overwrite(match.index, match.index + match[0].length, getReplacement(match));
    }
    return this;
  }
  toRollupResult(sourcemap = true, options) {
    const code = this.s.toString();
    if (code === this.s.original)
      return null;
    const result = { code };
    if (sourcemap)
      result.map = this.generateMap(options);
    return result;
  }
  hasChanged() {
    return this.s.toString() !== this.s.original;
  }
  toString() {
    return this.s.toString();
  }
  get original() {
    return this.s.original;
  }
  addSourcemapLocation(char) {
    this.s.addSourcemapLocation(char);
  }
  append(content) {
    this.s.append(content);
    return this;
  }
  appendLeft(index, content) {
    this.s.appendLeft(index, content);
    return this;
  }
  appendRight(index, content) {
    this.s.appendRight(index, content);
    return this;
  }
  clone() {
    const clone = new MagicStringExtra(this.s.clone());
    clone.defaultSourcemapOptions = __spreadValues({}, this.defaultSourcemapOptions);
    return clone;
  }
  generateMap(options) {
    return this.s.generateMap(__spreadValues(__spreadValues({}, this.defaultSourcemapOptions), options));
  }
  generateDecodedMap(options) {
    return this.s.generateDecodedMap(__spreadValues(__spreadValues({}, this.defaultSourcemapOptions), options));
  }
  getIndentString() {
    return this.s.getIndentString();
  }
  indent(arg1, arg2) {
    this.s.indent(arg1, arg2);
    return this;
  }
  get indentExclusionRanges() {
    return this.s.indentExclusionRanges;
  }
  move(start, end, index) {
    this.s.move(start, end, index);
    return this;
  }
  overwrite(start, end, content, options) {
    this.s.overwrite(start, end, content, options);
    return this;
  }
  prepend(content) {
    this.s.prepend(content);
    return this;
  }
  prependLeft(index, content) {
    this.s.prependLeft(index, content);
    return this;
  }
  prependRight(index, content) {
    this.s.prependRight(index, content);
    return this;
  }
  remove(start, end) {
    this.s.remove(start, end);
    return this;
  }
  slice(start, end) {
    return this.s.slice(start, end);
  }
  snip(start, end) {
    this.s.snip(start, end);
    return this;
  }
  trim(charType) {
    this.s.trim(charType);
    return this;
  }
  trimStart(charType) {
    this.s.trimStart(charType);
    return this;
  }
  trimEnd(charType) {
    this.s.trimEnd(charType);
    return this;
  }
  trimLines() {
    this.s.trimLines();
    return this;
  }
  lastChar() {
    return this.s.lastChar();
  }
  lastLine() {
    return this.s.lastLine();
  }
  isEmpty() {
    return this.s.isEmpty();
  }
  length() {
    return this.s.length();
  }
}

export { MagicStringExtra, MagicStringExtra as default };
